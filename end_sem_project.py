# -*- coding: utf-8 -*-
"""End_Sem_Project_G7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zwxeIp8QObzfmjdfxScyvlNXWCz-6Ine
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# from google.colab import files
# uploaded = files.upload()

df=pd.read_csv('C:/Users/rafiu/OneDrive/Desktop/DATA ANALYSIS/mental_health_dataset.csv')
print(df)

df.isnull().sum()

df.Student_ID.describe()

from sklearn.preprocessing import LabelEncoder
le_gender=LabelEncoder()
le_reflections=LabelEncoder()
le_mood=LabelEncoder()
le=LabelEncoder()
df['Gender']=le_gender.fit_transform(df['Gender'])
df['Daily_Reflections'] = le_reflections.fit_transform(df['Daily_Reflections'])
df['Mood_Description'] = le_mood.fit_transform(df['Mood_Description'])
df['Mental_Health_Status'] = le.fit_transform(df['Mental_Health_Status'])

df

from sklearn.preprocessing import MinMaxScaler
df_cols_to_normalize = ['Sentiment_Score', 'Steps_Per_Day', 'Daily_Reflections',
                        'Age', 'Anxiety_Score', 'GPA', 'Stress_Level', 'Sleep_Hours']
scaler = MinMaxScaler()
df[df_cols_to_normalize] = scaler.fit_transform(df[df_cols_to_normalize])

df

df.columns

sns.displot(df.Age)
plt.show()

sns.heatmap(df.isnull(), cbar=True, cmap='viridis')
plt.title('Missing Values Heatmap')
plt.show()

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.neural_network import MLPClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
from sklearn.metrics import precision_score,recall_score,f1_score,accuracy_score

#x = df[['Student_ID','Age','Gender','GPA','Stress_Level','Anxiety_Score','Depression_Score','Daily_Reflections','Sleep_Hours','Steps_Per_Day',
       # 'Mood_Description','Sentiment_Score']]

#y = df['Mental_Health_Status']

x = df.drop(['Mental_Health_Status', 'Student_ID'], axis=1)
y = df['Mental_Health_Status']

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)


print("--------------------------------------------------------------------------------------------------------------------------------------------RANDOM FOREST --------------------------------------------------------------------------------------------------------------------------------------------")

RFmodel = RandomForestClassifier()
RFmodel.fit(x_train, y_train)

y_predic = RFmodel.predict(x_test)

classification_report(y_test, y_predic)

studentmentalhealth_cm = confusion_matrix(y_test, y_predic)

disp = ConfusionMatrixDisplay(studentmentalhealth_cm,)
disp.plot()

print("Accuracy", accuracy_score(y_test, y_predic))
print("Precision", precision_score(y_test, y_predic, average = 'weighted'))
print("Recall", recall_score(y_test, y_predic, average = 'weighted'))
print("F1 Score", f1_score(y_test, y_predic, average = 'weighted'))

                            # from sklearn.linear_model import LinearRegression

                            # # Note: LinearRegression is for regression tasks.
                            # # Your target variable 'Mental_Health_Status' is categorical.
                            # # Consider using a classification model instead (e.g., LogisticRegression, RandomForestClassifier).

                            # model = LinearRegression(fit_intercept=True, n_jobs=-1, positive=True)
                            # model.fit(x_train, y_train)

                            # lreg_model = LogisticRegression(fit_intercept=True)
                            # lreg_model.fit(x_train, y_train)

                            # y_predic = lreg_model.predict(x_test)

                            # studentmentalhealth_cm = confusion_matrix(y_test, y_predic)

                            # disp = ConfusionMatrixDisplay(studentmentalhealth_cm,)
                            # disp.plot()

                            # print("Accuracy", accuracy_score(y_test, y_predic))
                            # print("Precision", precision_score(y_test, y_predic, zero_division=1, average = 'weighted'))
                            # print("Recall", recall_score(y_test, y_predic, average = 'weighted'))
                            # print("F1 Score", f1_score(y_test, y_predic, average = 'weighted'))

print("--------------------------------------------------------------------------------------------------------------------------------------------KNeighborsClassifier --------------------------------------------------------------------------------------------------------------------------------------------")


KNmodel = KNeighborsClassifier(
    n_neighbors=7,
    weights='distance',
    algorithm='auto',
    #leaf_size=30,
    p=2,
    metric='minkowski',
    #metric_params=None,
    n_jobs=-1
)
KNmodel.fit(x_train, y_train)

studentmentalhealth_cm = confusion_matrix(y_test, y_predic)

disp = ConfusionMatrixDisplay(studentmentalhealth_cm,)
disp.plot()

print("Accuracy", accuracy_score(y_test, y_predic))
print("Precision", precision_score(y_test, y_predic, average = 'weighted'))
print("Recall", recall_score(y_test, y_predic, average = 'weighted'))
print("F1 Score", f1_score(y_test, y_predic, average = 'weighted'))


print("--------------------------------------------------------------------------------------------------------------------------------------------MLP Classifier --------------------------------------------------------------------------------------------------------------------------------------------")


MLPmodel = MLPClassifier(
    hidden_layer_sizes=(64, 32),
    activation='relu',
    solver='adam',
    alpha=0.001,
    batch_size='auto',
    learning_rate='adaptive',
    learning_rate_init=0.01,
    max_iter=500,
    random_state=42,
    early_stopping =True,
    validation_fraction = 0.1
)

MLPmodel.fit(x_train, y_train)
y_predic = MLPmodel.predict(x_test)

studentmentalhealth_cm = confusion_matrix(y_test, y_predic)

disp = ConfusionMatrixDisplay(studentmentalhealth_cm,)
disp.plot()

print("Accuracy", accuracy_score(y_test, y_predic))
print("Precision", precision_score(y_test, y_predic, average = 'weighted', zero_division=0))
print("Recall", recall_score(y_test, y_predic, average = 'weighted'))
print("F1 Score", f1_score(y_test, y_predic, average = 'weighted', zero_division=0))

print("--------------------------------------------------------------------------------------------------------------------------------------------SVC MODEL --------------------------------------------------------------------------------------------------------------------------------------------")


SVmodel = SVC(
    C=1.0, gamma='scale', kernel='rbf')
SVmodel.fit(x_train, y_train)
y_predic = SVmodel.predict(x_test)

studentmentalhealth_cm = confusion_matrix(y_test, y_predic)

disp = ConfusionMatrixDisplay(studentmentalhealth_cm,)
disp.plot()

print("Accuracy", accuracy_score(y_test, y_predic))
print("Precision", precision_score(y_test, y_predic, average = 'weighted', zero_division=0))
print("Recall", recall_score(y_test, y_predic, average = 'weighted'))
print("F1 Score", f1_score(y_test, y_predic, average = 'weighted', zero_division=0))



print("--------------------------------------------------------------------------------------------------------------------------------------------STACKED MODEL (MLP + SVC + KNN + RF) --------------------------------------------------------------------------------------------------------------------------------------------")

from sklearn.ensemble import StackingClassifier
from sklearn.linear_model import LogisticRegression

# Recreate all base models

mlp_model = MLPClassifier(
    hidden_layer_sizes=(64, 32),
    activation='relu',
    solver='adam',
    alpha=0.001,
    batch_size='auto',
    learning_rate='adaptive',
    learning_rate_init=0.01,
    max_iter=500,
    random_state=42,
    early_stopping=True,
    validation_fraction=0.1
)

svc_model = SVC(
    C=1.0,
    gamma='scale',
    kernel='rbf',
    probability=True  # MUST be True for stacking
)

knn_model = KNeighborsClassifier(
    n_neighbors=7,
    weights='distance',
    algorithm='auto',
    p=2,
    metric='minkowski',
    n_jobs=-1
)

rf_model = RandomForestClassifier(random_state=42)

# Define the meta model (final decision maker)
meta_model = LogisticRegression(max_iter=1000)

# Stack all base models
stacked_model = StackingClassifier(
    estimators=[
        ('mlp', mlp_model),
        ('svc', svc_model),
        ('knn', knn_model),
        ('rf', rf_model)
    ],
    final_estimator=meta_model,
    cv=5  # cross-validation inside the stack
)

# Train stacked model
stacked_model.fit(x_train, y_train)

# Predict on test data
y_predic = stacked_model.predict(x_test)

# Confusion Matrix
studentmentalhealth_cm = confusion_matrix(y_test, y_predic)
disp = ConfusionMatrixDisplay(confusion_matrix=studentmentalhealth_cm)
disp.plot()

# Print metrics
print("Accuracy:", accuracy_score(y_test, y_predic))
print("Precision:", precision_score(y_test, y_predic, average='weighted', zero_division=0))
print("Recall:", recall_score(y_test, y_predic, average='weighted'))
print("F1 Score:", f1_score(y_test, y_predic, average='weighted', zero_division=0))



import os
from joblib import dump


# Save LabelEncoders and Scaler
dump(le_gender, 'c:/Users/rafiu/OneDrive/Desktop/DATA ANALYSIS/END OF SEM PROJECT/saved_models/le_gender.pkl')
dump(le_mood, 'c:/Users/rafiu/OneDrive/Desktop/DATA ANALYSIS/END OF SEM PROJECT/saved_models/le_mood.pkl')
dump(le_reflections, 'c:/Users/rafiu/OneDrive/Desktop/DATA ANALYSIS/END OF SEM PROJECT/saved_models/le_reflection.pkl')
dump(scaler, 'c:/Users/rafiu/OneDrive/Desktop/DATA ANALYSIS/END OF SEM PROJECT/saved_models/minmax_scaler.pkl')

# Get the current directory where your script is located
base_dir = os.path.dirname(os.path.abspath(__file__))

# Define your save path relative to your project
save_path = os.path.join(base_dir, "saved_models", "stacked_model.pkl")

# Make sure the folder exists
os.makedirs(os.path.dirname(save_path), exist_ok=True)

# Save the model
dump(stacked_model, save_path)
print(f"Model saved to: {save_path}")

